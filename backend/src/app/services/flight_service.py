import logging
import json
from typing import Any, List
from datetime import date # New Import for date handling

import httpx

from ..core.config import settings
from ..core.exceptions.http_exceptions import CustomException

logger = logging.getLogger(__name__)


class FlightServiceError(CustomException):
    """Custom exception for flight service errors."""

    def __init__(self, message: str, status_code: int = 503) -> None:
        self.message = message
        self.status_code = status_code
        super().__init__(status_code=status_code, detail=message)


class LocationProcessor:
    """
    Loads and processes airport/city/country data for generating API query keys.
    Note: Requires 'airport_data.json' to be generated by data_processor.py.
    """
    def __init__(self, data_file_path="/code/app/airport_data.json"):
        self.data_file_path = data_file_path
        self._lookup_data = self._load_data()

        # Data maps for fast lookup
        self.airport_map = self._lookup_data.get("AIRPORT_MAP", {})
        self.city_api_key_map = self._lookup_data.get("CITY_API_KEY_MAP", {})
        self.country_map = self._lookup_data.get("COUNTRY_MAP", {})
        self.ambiguous_city_map = self._lookup_data.get("AMBIGUOUS_CITY_MAP", {})

        if not self._lookup_data:
            logger.warning("Location data failed to load. Location lookups will fail.")

    def _load_data(self) -> dict[str, Any]:
        """Loads the pre-processed JSON data generated by data_processor.py."""
        try:
            with open(self.data_file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            logger.error(f"Data file not found at {self.data_file_path}. Run data_processor.py first.")
            return {}
        except json.JSONDecodeError:
            logger.error("Failed to decode JSON from the data file.")
            return {}

    def _get_entity_key(self, input_value: str) -> str | None:
        """
        Performs a lookup for a single input value and returns the required API key format.
        """
        input_value = input_value.strip().upper()

        if not input_value:
            return None

        # 1. Airport Lookup (BER -> Airport:BER)
        if len(input_value) == 3 and input_value in self.airport_map:
            return f"Airport:{input_value}"

        # 2. Country Lookup (GERMANY -> Country:DE)
        if input_value in self.country_map:
            country_code = self.country_map[input_value]
            return f"Country:{country_code}"

        # 3. Ambiguous City Lookup (e.g., "LONDON UNITED KINGDOM" or "LONDON GB")
        if input_value in self.ambiguous_city_map:
            normalized_key = self.ambiguous_city_map[input_value]
            return f"City:{normalized_key}"
            
        # 4. Simple City Lookup (If only a city name is provided)
        target_city_lower = input_value.lower()
        
        for city_country_key, city_name in self.city_api_key_map.items():
            if city_name.lower() == target_city_lower:
                return f"City:{city_country_key}"

        return None

    def process_locations(self, location_string: str) -> List[str]:
        """
        Processes a comma-separated string of locations and returns a list of API keys.
        """
        if not location_string:
            return []

        # Split the input string by comma and process each part
        inputs = [part.strip() for part in location_string.split(',') if part.strip()]
        
        results = []
        for input_value in inputs:
            key = self._get_entity_key(input_value)
            if key:
                results.append(key)
        
        return results


class FlightService:
    """Service for interacting with RapidAPI Kiwi.com Flight Search API."""

    def __init__(self) -> None:
        self.base_url = f"https://{settings.RAPIDAPI_HOST}"
        self.headers = {"x-rapidapi-key": settings.RAPIDAPI_KEY, "x-rapidapi-host": settings.RAPIDAPI_HOST}
        self.timeout = 30.0
        # Initialize the LocationProcessor
        self.location_processor = LocationProcessor() 

    def _build_query_params(self, request_data: dict[str, Any]) -> dict[str, Any]:
        """
        Build query parameters from request data, ensuring 'source' and 'destination'
        are processed first and applying default dates.
        """
        params = {}
        today_date_str = date.today().isoformat()
        
        # --- ORDER SENSITIVE LOGIC: 1. Process and set Source/Destination first ---

        # 1. Process 'source'
        source_input = request_data.get("source")
        if source_input:
            processed_sources = self.location_processor.process_locations(source_input)
            if processed_sources:
                # Add source as the first key
                params["source"] = ",".join(processed_sources)
            else:
                logger.warning(f"No valid source locations found for input: {source_input}")
        
        # 2. Process 'destination'
        destination_input = request_data.get("destination")
        if destination_input:
            processed_destinations = self.location_processor.process_locations(destination_input)
            if processed_destinations:
                # Add destination as the second key
                params["destination"] = ",".join(processed_destinations)
            else:
                logger.warning(f"No valid destination locations found for input: {destination_input}")
        
        # --- 2. Process all other parameters and apply date defaults ---

        field_mapping = {
            "source": "source", # Kept for comprehensive iteration, but skipped below
            "destination": "destination", # Kept for comprehensive iteration, but skipped below
            "currency": "currency",
            "locale": "locale",
            "adults": "adults",
            "children": "children",
            "infants": "infants",
            "handbags": "handbags",
            "holdbags": "holdbags",
            "cabin_class": "cabinClass",
            "sort_by": "sortBy",
            "sort_order": "sortOrder",
            "apply_mixed_classes": "applyMixedClasses",
            "allow_return_from_different_city": "allowReturnFromDifferentCity",
            "allow_change_inbound_destination": "allowChangeInboundDestination",
            "allow_change_inbound_source": "allowChangeInboundSource",
            "allow_different_station_connection": "allowDifferentStationConnection",
            "enable_self_transfer": "enableSelfTransfer",
            "allow_overnight_stopover": "allowOvernightStopover",
            "enable_true_hidden_city": "enableTrueHiddenCity",
            "enable_throw_away_ticketing": "enableThrowAwayTicketing",
            "price_start": "priceStart",
            "price_end": "priceEnd",
            "max_stops_count": "maxStopsCount",
            "outbound": "outbound",
            "transport_types": "transportTypes",
            "content_providers": "contentProviders",
            "limit": "limit",
            "inbound_departure_date_start": "inboundDepartureDateStart",
            "inbound_departure_date_end": "inboundDepartureDateEnd",
            "outbound_department_date_start": "outboundDepartmentDateStart",
            "outbound_department_date_end": "outboundDepartmentDateEnd",
            "departure_date_start": "departureDateStart",
            "departure_date_end": "departureDateEnd",
        }

        # Date fields that must default to today's date if missing
        date_start_fields = [
            "departure_date_start", 
            "outbound_department_date_start", 
            "inbound_departure_date_start"
        ]

        for field_name, api_param in field_mapping.items():
            value = request_data.get(field_name)

            # NEW LOGIC: Apply default date if missing
            if field_name in date_start_fields and value is None:
                # Set the default value to today's date string
                value = today_date_str 

            # Skip source and destination as they were handled and ordered above
            if field_name in ["source", "destination"]:
                continue
                
            if value is not None:
                if isinstance(value, bool):
                    params[api_param] = "true" if value else "false"
                else:
                    # Note: If value was defaulted, it is already a string
                    params[api_param] = value
        
        return params

    async def search_round_trip(self, request_data: dict[str, Any]) -> dict[str, Any]:
        """Search for round-trip flights via RapidAPI."""
        try:
            params = self._build_query_params(request_data)

            async with httpx.AsyncClient(timeout=self.timeout) as client:
                logger.info(
                    f"Requesting round-trip flights: {params.get('source')} -> {params.get('destination')}"
                )
                response = await client.get(f"{self.base_url}/round-trip", headers=self.headers, params=params)

                if response.status_code != 200:
                    logger.error(f"RapidAPI error: {response.status_code} - {response.text}")
                    raise FlightServiceError(
                        message=f"Failed to retrieve flights: HTTP {response.status_code}",
                        status_code=response.status_code,
                    )

                data = response.json()
                logger.info(f"Successfully fetched {len(data.get('data', []))} round-trip flights")
                return data

        except httpx.TimeoutException as e:
            logger.error(f"RapidAPI request timeout: {e}")
            raise FlightServiceError(message="Flight search request timed out", status_code=408)
        except httpx.RequestError as e:
            logger.error(f"RapidAPI connection error: {e}")
            raise FlightServiceError(message="Unable to connect to flight search service", status_code=503)
        except FlightServiceError:
            raise
        except Exception as e:
            logger.exception(f"Unexpected error in flight search: {e}")
            raise FlightServiceError(message="An unexpected error occurred during flight search", status_code=500)

    async def search_one_way(self, request_data: dict[str, Any]) -> dict[str, Any]:
        """Search for one-way flights via RapidAPI."""
        try:
            params = self._build_query_params(request_data)

            async with httpx.AsyncClient(timeout=self.timeout) as client:
                logger.info(f"Requesting one-way flights: {params.get('source')} -> {params.get('destination')}")
                response = await client.get(f"{self.base_url}/one-way", headers=self.headers, params=params)

                if response.status_code != 200:
                    logger.error(f"RapidAPI error: {response.status_code} - {response.text}")
                    raise FlightServiceError(
                        message=f"Failed to retrieve flights: HTTP {response.status_code}",
                        status_code=response.status_code,
                    )

                data = response.json()
                logger.info(f"Successfully fetched {len(data.get('data', []))} one-way flights")
                return data

        except httpx.TimeoutException as e:
            logger.error(f"RapidAPI request timeout: {e}")
            raise FlightServiceError(message="Flight search request timed out", status_code=408)
        except httpx.RequestError as e:
            logger.error(f"RapidAPI connection error: {e}")
            raise FlightServiceError(message="Unable to connect to flight search service", status_code=503)
        except FlightServiceError:
            raise
        except Exception as e:
            logger.exception(f"Unexpected error in flight search: {e}")
            raise FlightServiceError(message="An unexpected error occurred during flight search", status_code=500)


flight_service = FlightService()